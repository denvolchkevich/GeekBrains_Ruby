# Third lesson homework


# Для класса Hash:
  # Метод, принимающий блок и удаляющий пару, если условие внутри блока вычисляется в true:

    hash_1 = { :a => 100, :b => 200, :c => 300 }
    hash_1.select!{|key| key > :a}  # => {:b=>200, :c=>300}

  # Метод, проверяющий пуст ли хэш

    hash_1.empty?  # => false

  # Метод, принимающий аргументы переменной длины, каждый из которых является ключом хэша. Если удаётся
  # последовательно получить значение для каждого из ключей, возвращается это значение. Если нет - возвращается nil.

    storage = { data: { name: 'John' } }
    storage.dig(:data, :name) # => 'John'
    storage.dig(:data, :age)  # => nil


  # Для класса Symbol:
  # Метод, возвращающий массив всех определённых символов в памяти на данный момент

    p Symbol.all_symbols

  # Метод, проверяющий находится ли зданное имя символа между двумя другими заданными именами символов. Между –
  # имеется в виду проверка по кодам ASCII для символов из которых состоит объект класса Symbol

    p :b.between?(:a, :c)  # => true


# Для класса File:
  # Метод, превращающий путь к файлу в его абсолютный путь

    File.absolute_path('testfile')

  # Метод проверяющий, является ли данный файл каталогом

    File.directory?('Files')  # => true

  # Метод проверяющий существование файла

    File.exist?('another_testfile')  # => false

  # Метод возвращающий время модификации файла

    File.mtime('testfile') # => Wed Apr 09 08:53:13 CDT 2016


# Для класса Time:
  # Метод, возвращающий текущее время

    Time.now  # => 2016-09-14 11:33:01 +0300

  # Метод, проверяющий пятница ли сегодня

    Time.now.friday? # => false

  # Метод, возвращающий строку с названием часового пояса

    Time.now.zone  # => "MSK"


# Для модуля Kernel:
  # Метод, возволяющий исполнять любой Ruby код, переданный в качестве строки

    str = "text = 'Hello'\n p text"
    eval str  # => Hello

  # Метод, позволяющий приостановить работу программы на определённое количество секунд

    eval str
    sleep(1)
    eval str


# Напишите метод combination для поиска сочетаний в массиве элементов. Сравните производительность метода с
# одноимённым методом Ruby из класса Array при помощи модуля Benchmark.

    require 'benchmark'

    def combination(array, number)
      n = array.size
      v = (1..2**n).map do | m |
        (0..n).select { | i | m[i] == 1 }.map { | i | array[i] }
      end
      v.select{ | x | x.size == number }
    end

    elements = [:one, :two, :three, :four]

    p combination elements, 2

    p elements.combination(2).to_a

    Benchmark.bm(10) do |x|
      x.report('My') { combination elements, 2 }
      x.report('Ruby') { elements.combination(2).to_a }
    end


# Подумайте над любой задачей из реального мира, определите сущности и попробуйте представить их с помощью типов
# данных Ruby. Для каких сущностей вы определили собственные классы и почему?

=begin

    Класс: Автомобиль
    Свойства:   цвет,марка, модель - Symbol
                мощность, скорость - Float
                количество сидений - Fixnum
    Собственные классы: различные параметры автомобиля (расход, износ, ТО)

end

# Понаблюдайте и попробуйте описать (в виде свободного текста) процесс взаимодействия между объектами по аналогии с
# примером продавца.

=begin

    Вход в квартиру
    Объекты: человек, замок, дверь
    Человек вызывает метод "Открыть замок". Замок переводится из состояния "Закрыто" в состояние "Открыто", вызывает
метод у человека "Вытащить ключ" и сообщает ему, что можно взаимодействовать с ручкой двери. Человек вызывает метод
"Открыть дверь". Дверь вызывает у человек метод "Потянуть дверь" на себя или от себя в зависимости от положения человека.

end